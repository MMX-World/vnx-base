
// AUTO GENERATED by vnxcppcodegen

#ifndef INCLUDE_vnx_test_PACKAGE_HXX_
#define INCLUDE_vnx_test_PACKAGE_HXX_

#include <vnx/Type.h>

#include <vnx/package.hxx>

#ifdef VNX_TEST_EXPORT_ENABLE
#include <vnx_test_export.h>
#else
#ifndef VNX_TEST_EXPORT
#define VNX_TEST_EXPORT
#endif
#endif


namespace vnx {
namespace test {

void register_all_types();


class TestValue;
struct test_struct_t;

VNX_TEST_EXPORT extern const vnx::TypeCode* const vnx_native_type_code_TestValue; ///< \private
VNX_TEST_EXPORT extern const vnx::TypeCode* const vnx_native_type_code_test_struct_t; ///< \private

} // namespace vnx
} // namespace test


namespace vnx {

void read(TypeInput& in, ::vnx::test::TestValue& value, const TypeCode* type_code, const uint16_t* code); ///< \private
void read(TypeInput& in, ::vnx::test::test_struct_t& value, const TypeCode* type_code, const uint16_t* code); ///< \private

void write(TypeOutput& out, const ::vnx::test::TestValue& value, const TypeCode* type_code, const uint16_t* code); ///< \private
void write(TypeOutput& out, const ::vnx::test::test_struct_t& value, const TypeCode* type_code, const uint16_t* code); ///< \private

void read(std::istream& in, ::vnx::test::TestValue& value); ///< \private
void read(std::istream& in, ::vnx::test::test_struct_t& value); ///< \private

void write(std::ostream& out, const ::vnx::test::TestValue& value); ///< \private
void write(std::ostream& out, const ::vnx::test::test_struct_t& value); ///< \private

void accept(Visitor& visitor, const ::vnx::test::TestValue& value); ///< \private
void accept(Visitor& visitor, const ::vnx::test::test_struct_t& value); ///< \private

/// \private
template<>
struct type<::vnx::test::TestValue> {
	void read(TypeInput& in, ::vnx::test::TestValue& value, const TypeCode* type_code, const uint16_t* code) {
		vnx::read(in, value, type_code, code);
	}
	void write(TypeOutput& out, const ::vnx::test::TestValue& value, const TypeCode* type_code, const uint16_t* code) {
		vnx::write(out, value, type_code, code);
	}
	void read(std::istream& in, ::vnx::test::TestValue& value) {
		vnx::read(in, value);
	}
	void write(std::ostream& out, const ::vnx::test::TestValue& value) {
		vnx::write(out, value);
	}
	void accept(Visitor& visitor, const ::vnx::test::TestValue& value) {
		vnx::accept(visitor, value);
	}
	const TypeCode* get_type_code();
	void create_dynamic_code(std::vector<uint16_t>& code);
	void create_dynamic_code(std::vector<uint16_t>& code, const ::vnx::test::TestValue& value, bool special = false);
};

/// \private
template<>
struct type<::vnx::test::test_struct_t> {
	void read(TypeInput& in, ::vnx::test::test_struct_t& value, const TypeCode* type_code, const uint16_t* code) {
		vnx::read(in, value, type_code, code);
	}
	void write(TypeOutput& out, const ::vnx::test::test_struct_t& value, const TypeCode* type_code, const uint16_t* code) {
		vnx::write(out, value, type_code, code);
	}
	void read(std::istream& in, ::vnx::test::test_struct_t& value) {
		vnx::read(in, value);
	}
	void write(std::ostream& out, const ::vnx::test::test_struct_t& value) {
		vnx::write(out, value);
	}
	void accept(Visitor& visitor, const ::vnx::test::test_struct_t& value) {
		vnx::accept(visitor, value);
	}
	const TypeCode* get_type_code();
	void create_dynamic_code(std::vector<uint16_t>& code);
	void create_dynamic_code(std::vector<uint16_t>& code, const ::vnx::test::test_struct_t& value, bool special = false);
};


} // namespace vnx

#endif // INCLUDE_vnx_test_PACKAGE_HXX_
