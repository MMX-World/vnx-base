
// AUTO GENERATED by vnxcppcodegen

#include <vnx/package.hxx>
#include <vnx/BaseProxyClient.hxx>
#include <vnx/Hash64.hpp>
#include <vnx/Module.h>
#include <vnx/ModuleInterface_vnx_get_config.hxx>
#include <vnx/ModuleInterface_vnx_get_config_return.hxx>
#include <vnx/ModuleInterface_vnx_get_config_object.hxx>
#include <vnx/ModuleInterface_vnx_get_config_object_return.hxx>
#include <vnx/ModuleInterface_vnx_get_module_info.hxx>
#include <vnx/ModuleInterface_vnx_get_module_info_return.hxx>
#include <vnx/ModuleInterface_vnx_get_type_code.hxx>
#include <vnx/ModuleInterface_vnx_get_type_code_return.hxx>
#include <vnx/ModuleInterface_vnx_restart.hxx>
#include <vnx/ModuleInterface_vnx_restart_return.hxx>
#include <vnx/ModuleInterface_vnx_self_test.hxx>
#include <vnx/ModuleInterface_vnx_self_test_return.hxx>
#include <vnx/ModuleInterface_vnx_set_config.hxx>
#include <vnx/ModuleInterface_vnx_set_config_return.hxx>
#include <vnx/ModuleInterface_vnx_set_config_object.hxx>
#include <vnx/ModuleInterface_vnx_set_config_object_return.hxx>
#include <vnx/ModuleInterface_vnx_stop.hxx>
#include <vnx/ModuleInterface_vnx_stop_return.hxx>
#include <vnx/ProxyInterface_disable_export.hxx>
#include <vnx/ProxyInterface_disable_export_return.hxx>
#include <vnx/ProxyInterface_disable_forward.hxx>
#include <vnx/ProxyInterface_disable_forward_return.hxx>
#include <vnx/ProxyInterface_disable_import.hxx>
#include <vnx/ProxyInterface_disable_import_return.hxx>
#include <vnx/ProxyInterface_disable_tunnel.hxx>
#include <vnx/ProxyInterface_disable_tunnel_return.hxx>
#include <vnx/ProxyInterface_enable_export.hxx>
#include <vnx/ProxyInterface_enable_export_return.hxx>
#include <vnx/ProxyInterface_enable_forward.hxx>
#include <vnx/ProxyInterface_enable_forward_return.hxx>
#include <vnx/ProxyInterface_enable_import.hxx>
#include <vnx/ProxyInterface_enable_import_return.hxx>
#include <vnx/ProxyInterface_enable_tunnel.hxx>
#include <vnx/ProxyInterface_enable_tunnel_return.hxx>
#include <vnx/ProxyInterface_login.hxx>
#include <vnx/ProxyInterface_login_return.hxx>
#include <vnx/ProxyInterface_on_connect.hxx>
#include <vnx/ProxyInterface_on_connect_return.hxx>
#include <vnx/ProxyInterface_on_disconnect.hxx>
#include <vnx/ProxyInterface_on_disconnect_return.hxx>
#include <vnx/ProxyInterface_on_login.hxx>
#include <vnx/ProxyInterface_on_login_return.hxx>
#include <vnx/ProxyInterface_on_remote_connect.hxx>
#include <vnx/ProxyInterface_on_remote_connect_return.hxx>
#include <vnx/ProxyInterface_on_remote_login.hxx>
#include <vnx/ProxyInterface_on_remote_login_return.hxx>
#include <vnx/ProxyInterface_wait_on_connect.hxx>
#include <vnx/ProxyInterface_wait_on_connect_return.hxx>
#include <vnx/ProxyInterface_wait_on_disconnect.hxx>
#include <vnx/ProxyInterface_wait_on_disconnect_return.hxx>
#include <vnx/Session.hxx>
#include <vnx/TopicPtr.hpp>

#include <vnx/Generic.hxx>
#include <vnx/vnx.h>


namespace vnx {

BaseProxyClient::BaseProxyClient(const std::string& service_name)
	:	Client::Client(vnx::Hash64(service_name))
{
}

BaseProxyClient::BaseProxyClient(vnx::Hash64 service_addr)
	:	Client::Client(service_addr)
{
}

std::shared_ptr<const ::vnx::Session> BaseProxyClient::login(const std::string& name, const std::string& password) {
	auto _method = ::vnx::ProxyInterface_login::create();
	_method->name = name;
	_method->password = password;
	auto _return_value = vnx_request(_method, false);
	if(auto _result = std::dynamic_pointer_cast<const ::vnx::ProxyInterface_login_return>(_return_value)) {
		return _result->_ret_0;
	} else if(_return_value && !_return_value->is_void()) {
		return _return_value->get_field_by_index(0).to<std::shared_ptr<const ::vnx::Session>>();
	} else {
		throw std::logic_error("BaseProxyClient: invalid return value");
	}
}

void BaseProxyClient::enable_import(const std::string& topic_name) {
	auto _method = ::vnx::ProxyInterface_enable_import::create();
	_method->topic_name = topic_name;
	vnx_request(_method, false);
}

void BaseProxyClient::enable_import_async(const std::string& topic_name) {
	auto _method = ::vnx::ProxyInterface_enable_import::create();
	_method->topic_name = topic_name;
	vnx_request(_method, true);
}

void BaseProxyClient::disable_import(const std::string& topic_name) {
	auto _method = ::vnx::ProxyInterface_disable_import::create();
	_method->topic_name = topic_name;
	vnx_request(_method, false);
}

void BaseProxyClient::disable_import_async(const std::string& topic_name) {
	auto _method = ::vnx::ProxyInterface_disable_import::create();
	_method->topic_name = topic_name;
	vnx_request(_method, true);
}

void BaseProxyClient::enable_export(const std::string& topic_name) {
	auto _method = ::vnx::ProxyInterface_enable_export::create();
	_method->topic_name = topic_name;
	vnx_request(_method, false);
}

void BaseProxyClient::enable_export_async(const std::string& topic_name) {
	auto _method = ::vnx::ProxyInterface_enable_export::create();
	_method->topic_name = topic_name;
	vnx_request(_method, true);
}

void BaseProxyClient::disable_export(const std::string& topic_name) {
	auto _method = ::vnx::ProxyInterface_disable_export::create();
	_method->topic_name = topic_name;
	vnx_request(_method, false);
}

void BaseProxyClient::disable_export_async(const std::string& topic_name) {
	auto _method = ::vnx::ProxyInterface_disable_export::create();
	_method->topic_name = topic_name;
	vnx_request(_method, true);
}

void BaseProxyClient::enable_forward(const std::string& service_name, const int32_t& max_queue_ms, const int32_t& max_queue_size) {
	auto _method = ::vnx::ProxyInterface_enable_forward::create();
	_method->service_name = service_name;
	_method->max_queue_ms = max_queue_ms;
	_method->max_queue_size = max_queue_size;
	vnx_request(_method, false);
}

void BaseProxyClient::enable_forward_async(const std::string& service_name, const int32_t& max_queue_ms, const int32_t& max_queue_size) {
	auto _method = ::vnx::ProxyInterface_enable_forward::create();
	_method->service_name = service_name;
	_method->max_queue_ms = max_queue_ms;
	_method->max_queue_size = max_queue_size;
	vnx_request(_method, true);
}

void BaseProxyClient::disable_forward(const std::string& service_name) {
	auto _method = ::vnx::ProxyInterface_disable_forward::create();
	_method->service_name = service_name;
	vnx_request(_method, false);
}

void BaseProxyClient::disable_forward_async(const std::string& service_name) {
	auto _method = ::vnx::ProxyInterface_disable_forward::create();
	_method->service_name = service_name;
	vnx_request(_method, true);
}

void BaseProxyClient::enable_tunnel(const ::vnx::Hash64& tunnel_addr, const int32_t& max_queue_ms, const int32_t& max_queue_size) {
	auto _method = ::vnx::ProxyInterface_enable_tunnel::create();
	_method->tunnel_addr = tunnel_addr;
	_method->max_queue_ms = max_queue_ms;
	_method->max_queue_size = max_queue_size;
	vnx_request(_method, false);
}

void BaseProxyClient::enable_tunnel_async(const ::vnx::Hash64& tunnel_addr, const int32_t& max_queue_ms, const int32_t& max_queue_size) {
	auto _method = ::vnx::ProxyInterface_enable_tunnel::create();
	_method->tunnel_addr = tunnel_addr;
	_method->max_queue_ms = max_queue_ms;
	_method->max_queue_size = max_queue_size;
	vnx_request(_method, true);
}

void BaseProxyClient::disable_tunnel(const ::vnx::Hash64& tunnel_addr) {
	auto _method = ::vnx::ProxyInterface_disable_tunnel::create();
	_method->tunnel_addr = tunnel_addr;
	vnx_request(_method, false);
}

void BaseProxyClient::disable_tunnel_async(const ::vnx::Hash64& tunnel_addr) {
	auto _method = ::vnx::ProxyInterface_disable_tunnel::create();
	_method->tunnel_addr = tunnel_addr;
	vnx_request(_method, true);
}

::vnx::Hash64 BaseProxyClient::wait_on_connect() {
	auto _method = ::vnx::ProxyInterface_wait_on_connect::create();
	auto _return_value = vnx_request(_method, false);
	if(auto _result = std::dynamic_pointer_cast<const ::vnx::ProxyInterface_wait_on_connect_return>(_return_value)) {
		return _result->_ret_0;
	} else if(_return_value && !_return_value->is_void()) {
		return _return_value->get_field_by_index(0).to<::vnx::Hash64>();
	} else {
		throw std::logic_error("BaseProxyClient: invalid return value");
	}
}

::vnx::Hash64 BaseProxyClient::wait_on_disconnect() {
	auto _method = ::vnx::ProxyInterface_wait_on_disconnect::create();
	auto _return_value = vnx_request(_method, false);
	if(auto _result = std::dynamic_pointer_cast<const ::vnx::ProxyInterface_wait_on_disconnect_return>(_return_value)) {
		return _result->_ret_0;
	} else if(_return_value && !_return_value->is_void()) {
		return _return_value->get_field_by_index(0).to<::vnx::Hash64>();
	} else {
		throw std::logic_error("BaseProxyClient: invalid return value");
	}
}

void BaseProxyClient::on_connect() {
	auto _method = ::vnx::ProxyInterface_on_connect::create();
	vnx_request(_method, false);
}

void BaseProxyClient::on_connect_async() {
	auto _method = ::vnx::ProxyInterface_on_connect::create();
	vnx_request(_method, true);
}

void BaseProxyClient::on_disconnect() {
	auto _method = ::vnx::ProxyInterface_on_disconnect::create();
	vnx_request(_method, false);
}

void BaseProxyClient::on_disconnect_async() {
	auto _method = ::vnx::ProxyInterface_on_disconnect::create();
	vnx_request(_method, true);
}

void BaseProxyClient::on_remote_connect(const ::vnx::Hash64& process_id) {
	auto _method = ::vnx::ProxyInterface_on_remote_connect::create();
	_method->process_id = process_id;
	vnx_request(_method, false);
}

void BaseProxyClient::on_remote_connect_async(const ::vnx::Hash64& process_id) {
	auto _method = ::vnx::ProxyInterface_on_remote_connect::create();
	_method->process_id = process_id;
	vnx_request(_method, true);
}

void BaseProxyClient::on_login(const std::string& name, const std::string& password) {
	auto _method = ::vnx::ProxyInterface_on_login::create();
	_method->name = name;
	_method->password = password;
	vnx_request(_method, false);
}

void BaseProxyClient::on_login_async(const std::string& name, const std::string& password) {
	auto _method = ::vnx::ProxyInterface_on_login::create();
	_method->name = name;
	_method->password = password;
	vnx_request(_method, true);
}

void BaseProxyClient::on_remote_login(std::shared_ptr<const ::vnx::Session> remote_session) {
	auto _method = ::vnx::ProxyInterface_on_remote_login::create();
	_method->remote_session = remote_session;
	vnx_request(_method, false);
}

void BaseProxyClient::on_remote_login_async(std::shared_ptr<const ::vnx::Session> remote_session) {
	auto _method = ::vnx::ProxyInterface_on_remote_login::create();
	_method->remote_session = remote_session;
	vnx_request(_method, true);
}

::vnx::Object BaseProxyClient::vnx_get_config_object() {
	auto _method = ::vnx::ModuleInterface_vnx_get_config_object::create();
	auto _return_value = vnx_request(_method, false);
	if(auto _result = std::dynamic_pointer_cast<const ::vnx::ModuleInterface_vnx_get_config_object_return>(_return_value)) {
		return _result->_ret_0;
	} else if(_return_value && !_return_value->is_void()) {
		return _return_value->get_field_by_index(0).to<::vnx::Object>();
	} else {
		throw std::logic_error("BaseProxyClient: invalid return value");
	}
}

::vnx::Variant BaseProxyClient::vnx_get_config(const std::string& name) {
	auto _method = ::vnx::ModuleInterface_vnx_get_config::create();
	_method->name = name;
	auto _return_value = vnx_request(_method, false);
	if(auto _result = std::dynamic_pointer_cast<const ::vnx::ModuleInterface_vnx_get_config_return>(_return_value)) {
		return _result->_ret_0;
	} else if(_return_value && !_return_value->is_void()) {
		return _return_value->get_field_by_index(0).to<::vnx::Variant>();
	} else {
		throw std::logic_error("BaseProxyClient: invalid return value");
	}
}

void BaseProxyClient::vnx_set_config_object(const ::vnx::Object& config) {
	auto _method = ::vnx::ModuleInterface_vnx_set_config_object::create();
	_method->config = config;
	vnx_request(_method, false);
}

void BaseProxyClient::vnx_set_config_object_async(const ::vnx::Object& config) {
	auto _method = ::vnx::ModuleInterface_vnx_set_config_object::create();
	_method->config = config;
	vnx_request(_method, true);
}

void BaseProxyClient::vnx_set_config(const std::string& name, const ::vnx::Variant& value) {
	auto _method = ::vnx::ModuleInterface_vnx_set_config::create();
	_method->name = name;
	_method->value = value;
	vnx_request(_method, false);
}

void BaseProxyClient::vnx_set_config_async(const std::string& name, const ::vnx::Variant& value) {
	auto _method = ::vnx::ModuleInterface_vnx_set_config::create();
	_method->name = name;
	_method->value = value;
	vnx_request(_method, true);
}

::vnx::TypeCode BaseProxyClient::vnx_get_type_code() {
	auto _method = ::vnx::ModuleInterface_vnx_get_type_code::create();
	auto _return_value = vnx_request(_method, false);
	if(auto _result = std::dynamic_pointer_cast<const ::vnx::ModuleInterface_vnx_get_type_code_return>(_return_value)) {
		return _result->_ret_0;
	} else if(_return_value && !_return_value->is_void()) {
		return _return_value->get_field_by_index(0).to<::vnx::TypeCode>();
	} else {
		throw std::logic_error("BaseProxyClient: invalid return value");
	}
}

std::shared_ptr<const ::vnx::ModuleInfo> BaseProxyClient::vnx_get_module_info() {
	auto _method = ::vnx::ModuleInterface_vnx_get_module_info::create();
	auto _return_value = vnx_request(_method, false);
	if(auto _result = std::dynamic_pointer_cast<const ::vnx::ModuleInterface_vnx_get_module_info_return>(_return_value)) {
		return _result->_ret_0;
	} else if(_return_value && !_return_value->is_void()) {
		return _return_value->get_field_by_index(0).to<std::shared_ptr<const ::vnx::ModuleInfo>>();
	} else {
		throw std::logic_error("BaseProxyClient: invalid return value");
	}
}

void BaseProxyClient::vnx_restart() {
	auto _method = ::vnx::ModuleInterface_vnx_restart::create();
	vnx_request(_method, false);
}

void BaseProxyClient::vnx_restart_async() {
	auto _method = ::vnx::ModuleInterface_vnx_restart::create();
	vnx_request(_method, true);
}

void BaseProxyClient::vnx_stop() {
	auto _method = ::vnx::ModuleInterface_vnx_stop::create();
	vnx_request(_method, false);
}

void BaseProxyClient::vnx_stop_async() {
	auto _method = ::vnx::ModuleInterface_vnx_stop::create();
	vnx_request(_method, true);
}

vnx::bool_t BaseProxyClient::vnx_self_test() {
	auto _method = ::vnx::ModuleInterface_vnx_self_test::create();
	auto _return_value = vnx_request(_method, false);
	if(auto _result = std::dynamic_pointer_cast<const ::vnx::ModuleInterface_vnx_self_test_return>(_return_value)) {
		return _result->_ret_0;
	} else if(_return_value && !_return_value->is_void()) {
		return _return_value->get_field_by_index(0).to<vnx::bool_t>();
	} else {
		throw std::logic_error("BaseProxyClient: invalid return value");
	}
}


} // namespace vnx
