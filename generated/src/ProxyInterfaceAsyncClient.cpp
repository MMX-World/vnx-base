
// AUTO GENERATED by vnxcppcodegen

#include <vnx/package.hxx>
#include <vnx/ProxyInterfaceAsyncClient.hxx>
#include <vnx/Hash64.hpp>
#include <vnx/ProxyInterface_disable_export.hxx>
#include <vnx/ProxyInterface_disable_export_return.hxx>
#include <vnx/ProxyInterface_disable_forward.hxx>
#include <vnx/ProxyInterface_disable_forward_return.hxx>
#include <vnx/ProxyInterface_disable_import.hxx>
#include <vnx/ProxyInterface_disable_import_return.hxx>
#include <vnx/ProxyInterface_disable_tunnel.hxx>
#include <vnx/ProxyInterface_disable_tunnel_return.hxx>
#include <vnx/ProxyInterface_enable_export.hxx>
#include <vnx/ProxyInterface_enable_export_return.hxx>
#include <vnx/ProxyInterface_enable_forward.hxx>
#include <vnx/ProxyInterface_enable_forward_return.hxx>
#include <vnx/ProxyInterface_enable_import.hxx>
#include <vnx/ProxyInterface_enable_import_return.hxx>
#include <vnx/ProxyInterface_enable_tunnel.hxx>
#include <vnx/ProxyInterface_enable_tunnel_return.hxx>
#include <vnx/ProxyInterface_get_session.hxx>
#include <vnx/ProxyInterface_get_session_return.hxx>
#include <vnx/ProxyInterface_login.hxx>
#include <vnx/ProxyInterface_login_return.hxx>
#include <vnx/ProxyInterface_on_connect.hxx>
#include <vnx/ProxyInterface_on_connect_return.hxx>
#include <vnx/ProxyInterface_on_disconnect.hxx>
#include <vnx/ProxyInterface_on_disconnect_return.hxx>
#include <vnx/ProxyInterface_on_login.hxx>
#include <vnx/ProxyInterface_on_login_return.hxx>
#include <vnx/ProxyInterface_on_remote_connect.hxx>
#include <vnx/ProxyInterface_on_remote_connect_return.hxx>
#include <vnx/ProxyInterface_on_remote_login.hxx>
#include <vnx/ProxyInterface_on_remote_login_return.hxx>
#include <vnx/ProxyInterface_wait_on_connect.hxx>
#include <vnx/ProxyInterface_wait_on_connect_return.hxx>
#include <vnx/ProxyInterface_wait_on_disconnect.hxx>
#include <vnx/ProxyInterface_wait_on_disconnect_return.hxx>
#include <vnx/Session.hxx>

#include <vnx/Generic.hxx>
#include <vnx/vnx.h>


namespace vnx {

ProxyInterfaceAsyncClient::ProxyInterfaceAsyncClient(const std::string& service_name)
	:	AsyncClient::AsyncClient(vnx::Hash64(service_name))
{
}

ProxyInterfaceAsyncClient::ProxyInterfaceAsyncClient(vnx::Hash64 service_addr)
	:	AsyncClient::AsyncClient(service_addr)
{
}

uint64_t ProxyInterfaceAsyncClient::login(const std::string& name, const std::string& password, const std::function<void(std::shared_ptr<const ::vnx::Session>)>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_login::create();
	_method->name = name;
	_method->password = password;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 0;
		vnx_queue_login[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::enable_import(const std::string& topic_name, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_enable_import::create();
	_method->topic_name = topic_name;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 1;
		vnx_queue_enable_import[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::disable_import(const std::string& topic_name, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_disable_import::create();
	_method->topic_name = topic_name;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 2;
		vnx_queue_disable_import[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::enable_export(const std::string& topic_name, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_enable_export::create();
	_method->topic_name = topic_name;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 3;
		vnx_queue_enable_export[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::disable_export(const std::string& topic_name, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_disable_export::create();
	_method->topic_name = topic_name;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 4;
		vnx_queue_disable_export[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::enable_forward(const std::string& service_name, const int32_t& max_queue_ms, const int32_t& max_queue_size, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_enable_forward::create();
	_method->service_name = service_name;
	_method->max_queue_ms = max_queue_ms;
	_method->max_queue_size = max_queue_size;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 5;
		vnx_queue_enable_forward[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::disable_forward(const std::string& service_name, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_disable_forward::create();
	_method->service_name = service_name;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 6;
		vnx_queue_disable_forward[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::enable_tunnel(const ::vnx::Hash64& tunnel_addr, const int32_t& max_queue_ms, const int32_t& max_queue_size, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_enable_tunnel::create();
	_method->tunnel_addr = tunnel_addr;
	_method->max_queue_ms = max_queue_ms;
	_method->max_queue_size = max_queue_size;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 7;
		vnx_queue_enable_tunnel[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::disable_tunnel(const ::vnx::Hash64& tunnel_addr, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_disable_tunnel::create();
	_method->tunnel_addr = tunnel_addr;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 8;
		vnx_queue_disable_tunnel[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::get_session(const std::function<void(std::shared_ptr<const ::vnx::Session>)>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_get_session::create();
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 9;
		vnx_queue_get_session[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::wait_on_connect(const std::function<void(const ::vnx::Hash64&)>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_wait_on_connect::create();
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 10;
		vnx_queue_wait_on_connect[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::wait_on_disconnect(const std::function<void(const ::vnx::Hash64&)>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_wait_on_disconnect::create();
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 11;
		vnx_queue_wait_on_disconnect[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::on_connect(const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_on_connect::create();
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 12;
		vnx_queue_on_connect[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::on_disconnect(const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_on_disconnect::create();
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 13;
		vnx_queue_on_disconnect[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::on_remote_connect(const ::vnx::Hash64& process_id, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_on_remote_connect::create();
	_method->process_id = process_id;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 14;
		vnx_queue_on_remote_connect[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::on_login(const std::string& name, const std::string& password, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_on_login::create();
	_method->name = name;
	_method->password = password;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 15;
		vnx_queue_on_login[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

uint64_t ProxyInterfaceAsyncClient::on_remote_login(std::shared_ptr<const ::vnx::Session> remote_session, const std::function<void()>& _callback, const std::function<void(const vnx::exception&)>& _error_callback) {
	auto _method = ::vnx::ProxyInterface_on_remote_login::create();
	_method->remote_session = remote_session;
	const auto _request_id = ++vnx_next_id;
	{
		std::lock_guard<std::mutex> _lock(vnx_mutex);
		vnx_pending[_request_id] = 16;
		vnx_queue_on_remote_login[_request_id] = std::make_pair(_callback, _error_callback);
	}
	vnx_request(_method, _request_id);
	return _request_id;
}

int32_t ProxyInterfaceAsyncClient::vnx_purge_request(uint64_t _request_id, const vnx::exception& _ex) {
	std::unique_lock<std::mutex> _lock(vnx_mutex);
	const auto _iter = vnx_pending.find(_request_id);
	if(_iter == vnx_pending.end()) {
		return -1;
	}
	const auto _index = _iter->second;
	vnx_pending.erase(_iter);
	switch(_index) {
		case 0: {
			const auto _iter = vnx_queue_login.find(_request_id);
			if(_iter != vnx_queue_login.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_login.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 1: {
			const auto _iter = vnx_queue_enable_import.find(_request_id);
			if(_iter != vnx_queue_enable_import.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_enable_import.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 2: {
			const auto _iter = vnx_queue_disable_import.find(_request_id);
			if(_iter != vnx_queue_disable_import.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_disable_import.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 3: {
			const auto _iter = vnx_queue_enable_export.find(_request_id);
			if(_iter != vnx_queue_enable_export.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_enable_export.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 4: {
			const auto _iter = vnx_queue_disable_export.find(_request_id);
			if(_iter != vnx_queue_disable_export.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_disable_export.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 5: {
			const auto _iter = vnx_queue_enable_forward.find(_request_id);
			if(_iter != vnx_queue_enable_forward.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_enable_forward.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 6: {
			const auto _iter = vnx_queue_disable_forward.find(_request_id);
			if(_iter != vnx_queue_disable_forward.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_disable_forward.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 7: {
			const auto _iter = vnx_queue_enable_tunnel.find(_request_id);
			if(_iter != vnx_queue_enable_tunnel.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_enable_tunnel.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 8: {
			const auto _iter = vnx_queue_disable_tunnel.find(_request_id);
			if(_iter != vnx_queue_disable_tunnel.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_disable_tunnel.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 9: {
			const auto _iter = vnx_queue_get_session.find(_request_id);
			if(_iter != vnx_queue_get_session.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_get_session.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 10: {
			const auto _iter = vnx_queue_wait_on_connect.find(_request_id);
			if(_iter != vnx_queue_wait_on_connect.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_wait_on_connect.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 11: {
			const auto _iter = vnx_queue_wait_on_disconnect.find(_request_id);
			if(_iter != vnx_queue_wait_on_disconnect.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_wait_on_disconnect.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 12: {
			const auto _iter = vnx_queue_on_connect.find(_request_id);
			if(_iter != vnx_queue_on_connect.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_on_connect.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 13: {
			const auto _iter = vnx_queue_on_disconnect.find(_request_id);
			if(_iter != vnx_queue_on_disconnect.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_on_disconnect.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 14: {
			const auto _iter = vnx_queue_on_remote_connect.find(_request_id);
			if(_iter != vnx_queue_on_remote_connect.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_on_remote_connect.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 15: {
			const auto _iter = vnx_queue_on_login.find(_request_id);
			if(_iter != vnx_queue_on_login.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_on_login.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
		case 16: {
			const auto _iter = vnx_queue_on_remote_login.find(_request_id);
			if(_iter != vnx_queue_on_remote_login.end()) {
				const auto _callback = std::move(_iter->second.second);
				vnx_queue_on_remote_login.erase(_iter);
				_lock.unlock();
				if(_callback) {
					_callback(_ex);
				}
			}
			break;
		}
	}
	return _index;
}

int32_t ProxyInterfaceAsyncClient::vnx_callback_switch(uint64_t _request_id, std::shared_ptr<const vnx::Value> _value) {
	std::unique_lock<std::mutex> _lock(vnx_mutex);
	const auto _iter = vnx_pending.find(_request_id);
	if(_iter == vnx_pending.end()) {
		throw std::runtime_error("ProxyInterfaceAsyncClient: received unknown return");
	}
	const auto _index = _iter->second;
	vnx_pending.erase(_iter);
	switch(_index) {
		case 0: {
			const auto _iter = vnx_queue_login.find(_request_id);
			if(_iter == vnx_queue_login.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_login.erase(_iter);
			_lock.unlock();
			if(_callback) {
				if(auto _result = std::dynamic_pointer_cast<const ::vnx::ProxyInterface_login_return>(_value)) {
					_callback(_result->_ret_0);
				} else if(_value && !_value->is_void()) {
					_callback(_value->get_field_by_index(0).to<std::shared_ptr<const ::vnx::Session>>());
				} else {
					throw std::logic_error("ProxyInterfaceAsyncClient: invalid return value");
				}
			}
			break;
		}
		case 1: {
			const auto _iter = vnx_queue_enable_import.find(_request_id);
			if(_iter == vnx_queue_enable_import.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_enable_import.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 2: {
			const auto _iter = vnx_queue_disable_import.find(_request_id);
			if(_iter == vnx_queue_disable_import.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_disable_import.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 3: {
			const auto _iter = vnx_queue_enable_export.find(_request_id);
			if(_iter == vnx_queue_enable_export.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_enable_export.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 4: {
			const auto _iter = vnx_queue_disable_export.find(_request_id);
			if(_iter == vnx_queue_disable_export.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_disable_export.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 5: {
			const auto _iter = vnx_queue_enable_forward.find(_request_id);
			if(_iter == vnx_queue_enable_forward.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_enable_forward.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 6: {
			const auto _iter = vnx_queue_disable_forward.find(_request_id);
			if(_iter == vnx_queue_disable_forward.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_disable_forward.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 7: {
			const auto _iter = vnx_queue_enable_tunnel.find(_request_id);
			if(_iter == vnx_queue_enable_tunnel.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_enable_tunnel.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 8: {
			const auto _iter = vnx_queue_disable_tunnel.find(_request_id);
			if(_iter == vnx_queue_disable_tunnel.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_disable_tunnel.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 9: {
			const auto _iter = vnx_queue_get_session.find(_request_id);
			if(_iter == vnx_queue_get_session.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_get_session.erase(_iter);
			_lock.unlock();
			if(_callback) {
				if(auto _result = std::dynamic_pointer_cast<const ::vnx::ProxyInterface_get_session_return>(_value)) {
					_callback(_result->_ret_0);
				} else if(_value && !_value->is_void()) {
					_callback(_value->get_field_by_index(0).to<std::shared_ptr<const ::vnx::Session>>());
				} else {
					throw std::logic_error("ProxyInterfaceAsyncClient: invalid return value");
				}
			}
			break;
		}
		case 10: {
			const auto _iter = vnx_queue_wait_on_connect.find(_request_id);
			if(_iter == vnx_queue_wait_on_connect.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_wait_on_connect.erase(_iter);
			_lock.unlock();
			if(_callback) {
				if(auto _result = std::dynamic_pointer_cast<const ::vnx::ProxyInterface_wait_on_connect_return>(_value)) {
					_callback(_result->_ret_0);
				} else if(_value && !_value->is_void()) {
					_callback(_value->get_field_by_index(0).to<::vnx::Hash64>());
				} else {
					throw std::logic_error("ProxyInterfaceAsyncClient: invalid return value");
				}
			}
			break;
		}
		case 11: {
			const auto _iter = vnx_queue_wait_on_disconnect.find(_request_id);
			if(_iter == vnx_queue_wait_on_disconnect.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_wait_on_disconnect.erase(_iter);
			_lock.unlock();
			if(_callback) {
				if(auto _result = std::dynamic_pointer_cast<const ::vnx::ProxyInterface_wait_on_disconnect_return>(_value)) {
					_callback(_result->_ret_0);
				} else if(_value && !_value->is_void()) {
					_callback(_value->get_field_by_index(0).to<::vnx::Hash64>());
				} else {
					throw std::logic_error("ProxyInterfaceAsyncClient: invalid return value");
				}
			}
			break;
		}
		case 12: {
			const auto _iter = vnx_queue_on_connect.find(_request_id);
			if(_iter == vnx_queue_on_connect.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_on_connect.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 13: {
			const auto _iter = vnx_queue_on_disconnect.find(_request_id);
			if(_iter == vnx_queue_on_disconnect.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_on_disconnect.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 14: {
			const auto _iter = vnx_queue_on_remote_connect.find(_request_id);
			if(_iter == vnx_queue_on_remote_connect.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_on_remote_connect.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 15: {
			const auto _iter = vnx_queue_on_login.find(_request_id);
			if(_iter == vnx_queue_on_login.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_on_login.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		case 16: {
			const auto _iter = vnx_queue_on_remote_login.find(_request_id);
			if(_iter == vnx_queue_on_remote_login.end()) {
				throw std::runtime_error("ProxyInterfaceAsyncClient: callback not found");
			}
			const auto _callback = std::move(_iter->second.first);
			vnx_queue_on_remote_login.erase(_iter);
			_lock.unlock();
			if(_callback) {
				_callback();
			}
			break;
		}
		default:
			if(_index >= 0) {
				throw std::logic_error("ProxyInterfaceAsyncClient: invalid callback index");
			}
	}
	return _index;
}


} // namespace vnx
